from mesa import Agent
from mesa import Model
from mesa import Agent, Model
from mesa.time import RandomActivation # Mesa.time handles the time component of the model. I contains schedulers that handles agent activations. RandomActivation is a scheduler that activates each agent once per step, in random order with order reshuffled every step
from mesa.datacollection import DataCollector # DataCollector is a standard way to collect data generated by a Mesa model. They can be modellevel data, agent-level data and tables
from mesa.space import MultiGrid # To add spatial component to the model. Under Multigrid, each cell can contain a set of agents
import random
import numpy as np
import sys
from matplotlib.pyplot import *
import random
import pandas as pd
from itertools import product


class MyAgent(Agent): #Agent Class
	def __init__(self, unique_id, model,AV,endow,slope,intercept,c_b,w_b,allow_h2o,conu,exo_price,conur,h2o,ret,distrib_comb,techno,senior,field,tot_h2o,river_m,yield_agents,revenue,pr_wtp,pr_wta,pr_bid,pr_ask):
		super().__init__(unique_id, model)
		self.AV = AV
		self.endow = endow
		self.slope = slope
		self.intercept = intercept
		self.river_m=river_m
		self.c_b=c_b
		self.w_b=w_b
		self.allow_h2o=allow_h2o
		self.conu=conu
		self.exo_price=exo_price
		self.conur=conur
		self.h2o=h2o
		self.ret=ret
		self.distrib_comb=distrib_comb
		self.techno=techno
		self.senior=senior
		self.field=field
		self.tot_h2o=tot_h2o
		self.yield_agents=yield_agents
		self.revenue=revenue
		self.pr_wtp=pr_wtp
		self.pr_wta=pr_wta
		self.pr_bid=pr_bid
		self.pr_ask=pr_ask
		self.price1=0.0
		self.price2=0.0
		self.gain=0.0

	def trade(self, dr_no, ss_s, ss_b, pp, qq, rr):  # Trading Method
		if self.senior<=dr_no-1:
			arr=[]
			ww=self.model.schedule.get_agent_count()
			for kk in range(ww):
				if self.model.schedule.agents[kk].senior>dr_no-1:
					arr.append(self.model.schedule.agents[kk])
			if len(arr)>0:
				other_agent = self.random.choice(arr) #choosing the other agent
			if len(arr)==0:
				other_agent = self.random.choice(self.model.schedule.agents)
		
		if self.senior>dr_no-1:
			arr=[]
			ww=self.model.schedule.get_agent_count()
			for kk in range(ww):
				if self.model.schedule.agents[kk].senior<=dr_no-1:
					arr.append(self.model.schedule.agents[kk])
			if len(arr)>0:
				other_agent = self.random.choice(arr) #choosing the other agent
			if len(arr)==0:
				other_agent = self.random.choice(self.model.schedule.agents)

		#CASE_1: self=Seller and other_agent=Buyer
		if self.senior <= dr_no-1 and other_agent.senior > dr_no-1:
			if self.AV < other_agent.AV and self.distrib_comb==other_agent.distrib_comb and self.river_m < other_agent.river_m and self.c_b <= (other_agent.c_b-other_agent.endow) and self.pr_ask <= other_agent.pr_wtp and other_agent.AV > 0.0:# and self.unique_id not in id_agent and other_agent.unique_id not in id_agent:
				other_agent.pr_wtp=(other_agent.intercept-other_agent.slope*self.c_b)*self.c_b
				if self.pr_ask <= other_agent.pr_wtp:
					if other_agent.pr_bid >= self.pr_ask:
						self.price2 = other_agent.pr_bid #(self.AV + other_agent.AV)/2. #updating selling price of the Seller
						other_agent.price1 = other_agent.pr_bid #(self.AV + other_agent.AV)/2. #updating buying price of the Buyer
						ss_s[self.unique_id]=self.revenue+self.price2*self.conu #storing profit of Seller
						ss_b[other_agent.unique_id]=other_agent.revenue-other_agent.price1*other_agent.conu #Storing profit of Buyer
						self.endow = self.endow - self.c_b #updating the consumptive use of Seller
						other_agent.endow = other_agent.endow + self.c_b #updating the consumptive use of Buyer
						pp[other_agent.unique_id]=other_agent.price1 #storing Buying price
						qq[self.unique_id]=self.price2 #storing Selling price
						self.gain = (other_agent.pr_wtp-self.pr_wta)*other_agent.endow #other_agent.AV - self.AV #updating the gain
						other_agent.gain = (other_agent.pr_wtp-self.pr_wta)*other_agent.endow #other_agent.AV - self.AV
						rr[self.unique_id]=self.gain #storing gain of Seller
						rr[other_agent.unique_id]=other_agent.gain #storing gain of Buyer
						self.AV = -self.slope*self.endow + self.intercept #updating the AV of Seller
						other_agent.AV = -other_agent.slope*other_agent.endow + other_agent.intercept #updating the AV of Buyer
						if other_agent.endow >= other_agent.c_b: 
							self.model.schedule.remove(other_agent) #removing the Buyer (as its endow equals conu)
						if self.endow <=0: #can also be set equal to 0
							self.model.schedule.remove(self) #removing the Seller
					elif other_agent.pr_bid < self.pr_ask:
						self.price2 = self.pr_ask #(self.AV + other_agent.AV)/2. #updating selling price of the Seller
						other_agent.price1 = self.pr_ask #(self.AV + other_agent.AV)/2. #updating buying price of the Buyer
						ss_s[self.unique_id]=self.revenue+self.price2*self.conu #storing profit of Seller
						ss_b[other_agent.unique_id]=other_agent.revenue-other_agent.price1*other_agent.conu #Storing profit of Buyer
						self.endow = self.endow - self.c_b #updating the consumptive use of Seller
						other_agent.endow = other_agent.endow + self.c_b #updating the consumptive use of Buyer
						pp[other_agent.unique_id]=other_agent.price1 #storing Buying price
						qq[self.unique_id]=self.price2 #storing Selling price
						self.gain = (other_agent.pr_wtp-self.pr_wta)*other_agent.endow #other_agent.AV - self.AV #updating the gain
						other_agent.gain = (other_agent.pr_wtp-self.pr_wta)*other_agent.endow #other_agent.AV - self.AV
						rr[self.unique_id]=self.gain #storing gain of Seller
						rr[other_agent.unique_id]=other_agent.gain #storing gain of Buyer
						self.AV = -self.slope*self.endow + self.intercept #updating the AV of Seller
						other_agent.AV = -other_agent.slope*other_agent.endow + other_agent.intercept #updating the AV of Buyer
						if other_agent.endow >= other_agent.c_b: 
							self.model.schedule.remove(other_agent) #removing the Buyer (as its endow equals conu)
						if self.endow <=0: #can also be set equal to 0
							self.model.schedule.remove(self) #removing the Seller
		
			elif self.price2 > 0.0: #if Seller has already traded in this iteration, then its Selling price should not go to 0
				qq[self.unique_id]=self.price2 + 0.0

		#CASE_2: self=Buyer and other_agent=Seller	
		elif self.senior > dr_no-1 and other_agent.senior <= dr_no-1:
			if self.AV > other_agent.AV and self.distrib_comb == other_agent.distrib_comb and self.river_m > other_agent.river_m and (self.c_b-self.endow) >= other_agent.c_b and self.pr_wtp >= other_agent.pr_ask and other_agent.AV > 0.0:# and other_agent.pr_ask <= self.pr_wtp:# and self.unique_id not in id_agent and other_agent.unique_id not in id_agent:
				self.pr_wtp=(self.intercept-self.slope*other_agent.c_b)*other_agent.c_b
				if other_agent.pr_ask <= self.pr_wtp:						
					if self.pr_bid >= other_agent.pr_ask:
						self.price1 = self.pr_bid #(self.AV + other_agent.AV)/2.
						other_agent.price2 = self.pr_bid #(self.AV + other_agent.AV)/2.
						ss_s[other_agent.unique_id]=other_agent.revenue+other_agent.price2*other_agent.conu
						ss_b[self.unique_id]=self.revenue-self.price1*self.conu
						self.endow = self.endow + other_agent.c_b
						other_agent.endow = other_agent.endow - other_agent.c_b
						pp[self.unique_id]=self.price1
						qq[other_agent.unique_id]=other_agent.price2
						self.gain = (self.pr_wtp-other_agent.pr_wta)*self.endow #self.AV - other_agent.AV
						other_agent.gain = (self.pr_wtp-other_agent.pr_wta)*self.endow #self.AV - other_agent.AV
						rr[self.unique_id]=self.gain
						rr[other_agent.unique_id]=other_agent.gain
						self.AV = -self.slope*self.endow + self.intercept
						other_agent.AV = -other_agent.slope*other_agent.endow + other_agent.intercept
						if self.endow >= self.c_b:
							self.model.schedule.remove(self)
						if other_agent.endow <= 0:
							self.model.schedule.remove(other_agent)
					elif self.pr_bid < other_agent.pr_ask:
						self.price1 = other_agent.pr_ask #(self.AV + other_agent.AV)/2.
						other_agent.price2 = other_agent.pr_ask #(self.AV + other_agent.AV)/2.
						ss_s[other_agent.unique_id]=other_agent.revenue+other_agent.price2*other_agent.conu
						ss_b[self.unique_id]=self.revenue-self.price1*self.conu
						self.endow = self.endow + other_agent.c_b
						other_agent.endow = other_agent.endow - other_agent.c_b
						pp[self.unique_id]=self.price1
						qq[other_agent.unique_id]=other_agent.price2
						self.gain = (self.pr_wtp-other_agent.pr_wta)*self.endow #self.AV - other_agent.AV
						other_agent.gain = (self.pr_wtp-other_agent.pr_wta)*self.endow #self.AV - other_agent.AV
						rr[self.unique_id]=self.gain
						rr[other_agent.unique_id]=other_agent.gain
						self.AV = -self.slope*self.endow + self.intercept
						other_agent.AV = -other_agent.slope*other_agent.endow + other_agent.intercept
						if self.endow >= self.c_b:
							self.model.schedule.remove(self)
						if other_agent.endow <= 0:
							self.model.schedule.remove(other_agent)
			elif other_agent.price2 > 0.0:
				qq[other_agent.unique_id]=other_agent.price2 + 0.0

		#if they do not trade anymore in this iteration, then their Selling and Buying prices should not be 0
		elif self.senior > dr_no-1 and other_agent.senior > dr_no-1:
			pp[self.unique_id] = self.price1 + 0.0
			qq[other_agent.unique_id] = other_agent.price2 + 0.0
			qq[self.unique_id] = self.price2 + 0.0
			pp[other_agent.unique_id] = other_agent.price1 + 0.0
		elif self.senior <= dr_no-1 and other_agent.senior <= dr_no-1:
			pp[self.unique_id] = self.price1 + 0.0
			qq[other_agent.unique_id] = other_agent.price2 + 0.0
			qq[self.unique_id] = self.price2 + 0.0
			pp[other_agent.unique_id] = other_agent.price1 + 0.0


	def step(self, pp, qq): #method to check if agent can at all trade
		if self.AV > 0.0:
			self.trade() #function for trading
		elif self.AV < 0.0:
			pp[self.unique_id]=0.0 #Buying price set to 0
			qq[self.unique_id]=0.0 #Selling price set to 0
		else:
			pass

			

def compute_price(model):
	agent_price = [agent.price1 for agent in model.schedule.agents]
	return agent_price



class Trade_Model(Model): # Trading Class
	def __init__(self, N,cu,ex_price,trib_comb,riv_m,cur,water,ret_fl,tech,sen_id,land,tot_water,seed=None ):
		global gamma

		self.num_agents = N #number of total agents
		self.schedule = RandomActivation(self)  #activation of the interaction
		self.running = True #model attribute

		#initialising empty arrays
		return_water=[]
		avg_val=[]
		endowment=[]
		sl=[]
		interc=[]
		c_bar=[]
		w_bar=[]
		allow_water=[]
		yield_all=[]
		rev=[]
		P_wtp=[]
		P_wta=[]
		P_bid=[]
		P_ask=[]
		gamma=1.0
		eps_s=(dr_no-1)/self.num_agents #number of sellers is (dr_no-1)
		eps_b=(self.num_agents-(dr_no-1))/self.num_agents #number of buyers is (num_agents-dr_no+1)

		for i in range(self.num_agents):
			if sen_list[i] <= dr_no-1: #checking if sen_id is less than dr_no
				sl.append(random.uniform(0,2))
				interc.append(random.uniform(20,40))#(2*sl[i]*endowment[i])
				c_bar.append(interc[i]/(2*sl[i]))
				endowment.append(c_bar[i])
				avg_val.append(interc[i]-sl[i]*endowment[i])
				P_wtp.append('NA')
				P_wta.append(avg_val[i]*c_bar[i])
				P_bid.append('NA')
				P_ask.append(P_wta[i]*(1+gamma*eps_b))
				w_bar.append(c_bar[i]/cur[i])
				return_water.append(w_bar[i]-c_bar[i])
				allow_water.append(w_bar[i]*land[i])
				yield_all.append(interc[i]*c_bar[i]-sl[i]*(c_bar[i])**2)
				rev.append(ex_price[i]*yield_all[i])
	

			elif sen_list[i] > dr_no-1: #checking if sen_id is more than dr_no
				sl.append(random.uniform(0,2))
				interc.append(random.uniform(20,40))#(2*sl[i]*cu[i])
				c_bar.append(interc[i]/(2*sl[i]))
				endowment.append(0)
				avg_val.append(interc[i]-sl[i]*endowment[i])
				P_wtp.append(avg_val[i]*c_bar[i])
				P_wta.append('NA')
				P_bid.append(P_wtp[i]*(1-gamma*eps_s))
				P_ask.append('NA')
				w_bar.append(c_bar[i]/cur[i])
				return_water.append(w_bar[i]-c_bar[i])
				allow_water.append(w_bar[i]*land[i])
				yield_all.append(interc[i]*c_bar[i]-sl[i]*(c_bar[i])**2)
				rev.append(ex_price[i]*yield_all[i])

		for i in range(self.num_agents): #runs over all the agents (one at a time)
			#initialising each agent
			a = MyAgent(i, self,avg_val[i],endowment[i],sl[i],interc[i],c_bar[i],w_bar[i],allow_water[i],cu[i],ex_price[i],cur[i],water[i],ret_fl[i],trib_comb[i],tech[i],sen_list[i],land[i],tot_water[i],riv_m[i],yield_all[i],rev[i],P_wtp[i],P_wta[i],P_bid[i],P_ask[i])
			#adding to the scheduler
			self.schedule.add(a)
		#for collecting the data
		self.datacollector = DataCollector(
			model_reporters = {"Agent Price": compute_price},
			agent_reporters={"Price1": "price1","Price2": "price2","Endowment": "endow","AV": "AV","Slope":"slope","Intercept":"intercept","c_bar":"c_b","w_bar":"w_b","Allowable_water":"allow_h2o","gft":"gain","Con_use":"conu","Exo_price":"exo_price","Con_use_r":"conur","Water":"h2o","Return":"ret","Trib_comb":"distrib_comb","Technology":"techno","Seniority":"senior","Land":"field","Total_water":"tot_h2o","River_m":"river_m","Yield":"yield_agents","Revenue":"revenue","Pr_wtp":"pr_wtp","Pr_wta":"pr_wta","Pr_bid":"pr_bid","Pr_ask":"pr_ask"})

	# method for starting the interaction between agents
	def mystep(self):
		self.datacollector.collect(self)
		self.schedule.step() #randomly starts trading